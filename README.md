

整体流程如下：

1. **初始化阶段** ：LLM 根据输入的自然语言描述 $\mathcal{L}$ 和接口信息 $\mathcal{I}$ 随机生成初始的 Domain 文件 $\hat{d}^{(0)}$，以及三个初始 Problem 文件 ${\hat{p}_1^{(0)}, \hat{p}_2^{(0)}, \hat{p}_3^{(0)}}$。
2. **修复过程** ：依次遍历每个问题文件，对每个 $\hat{p}_i$：

* 在当前 $\hat{d}^{(t)}$ 上尝试调用规划器。
* 若规划失败，则根据失败信息采集轨迹并修复 Domain 文件，更新为 $\hat{d}^{(t+1)}$。
* 重复上述过程直到规划器成功生成可行解。

1. **最终验证** ：使用修复后的 Domain $\hat{d}^*$ 重新翻译其他问题文件，并使用规划器生成计划序列。以成功验证率或 EW 分数作为评估标准。

本方法的关键在于提出了 **轨迹驱动的域修复机制** ，能够将反馈信号从“是否成功”提升为“如何修复”。

### 4.3 轨迹收集与分类机制

由于 LLM 生成的 Domain 文件常存在谓词缺失、前置条件不全、动作效果不完整等问题，导致规划器失败或产生不可达目标状态。因此我们设计了一个结合随机采样与广度优先搜索（BFS）的轨迹采样算法，用于深入分析执行失败的原因，并为 Domain 修复提供依据。

#### 轨迹收集算法

轨迹采样从初始状态 $s_0$ 开始，尝试构建从 $s_0$ 到任意目标状态 $s_g$ 的可执行动作序列。采用的算法流程如下：

**初始化：**

* 状态集合 $V = {s_0}$；
* 队列 $Q = {(s_0, [], [])}$，每个元素为当前状态、动作序列、状态转换序列三元组。

**搜索过程：**
在 $Q$ 非空且搜索深度小于最大阈值 $\text{max_depth}$ 时重复：

1. **出队** ：取出 $(s, A_s, T_s)$；
2. **目标检查** ：若 $s$ 满足目标谓词条件（正谓词 $\subset s$，负谓词 $\cap s = \emptyset$），则认为该轨迹为成功轨迹；
3. **动作采样** ：从所有可用动作集合 $A$ 中进行随机排序；
4. **动作执行** ：

* 对每个动作 $a$，检查其前置条件是否满足；
* 若可执行，则应用其效果函数 $T(s, a)$ 得到新状态 $s'$；
* 若 $s' \notin V$，则将其加入访问集与队列，记录轨迹。

此过程中将生成多种类型的轨迹，分为以下两类：

* ✅  **成功轨迹** ：最终状态满足目标条件；
* ⚠️  **伪成功轨迹** ：轨迹在当前 Domain 中可执行，但最终状态不满足目标，可能由于动作效果不完整或目标表达缺失；
* ❌  **非法轨迹** ：动作在真实语义上应可执行，但被当前 Domain 拒绝，说明前提条件可能设置过于保守。

---

### 4.4 基于轨迹的Domain修复策略

针对不同类型轨迹的反馈，我们制定如下修复策略：

* **伪成功轨迹 ➜ 修复动作效果（Effects）**

  通过分析成功轨迹中动作执行后状态的变化，若某些目标谓词未出现在最终状态，说明动作缺少必要的添加效果，应补充 $E^+$ 集合。
* **非法轨迹 ➜ 修复动作前提（Preconditions）**

  若某个应可执行动作在当前状态下被拒绝，表明其前提条件过于严格，应适当放宽 $P^+$ 或 $P^-$ 条件。

修复操作以增量形式进行，即每次修复仅调整一个动作的一个逻辑成分，避免过拟合与语义漂移。在每轮修复后，重新调用规划器验证问题是否可解，直至成功或达到最大迭代次数。

### 4.5 评价指标

为了更全面地评估生成的 PDDL 文件质量，我们引入以下指标：

* **验证成功率** （Success Rate）：生成计划通过验证器的比例。

# 轨迹收集算法的详细数学解释

## 算法概述

轨迹收集算法使用修改版的广度优先搜索（BFS）与随机采样相结合。以下是详细的形式化描述：

### 初始化

1. 从初始状态 $s_0$ 开始        2. 已访问状态集合初始化：$V = \{s_0\}$        3. 探索队列初始化：$Q = \{(s_0, [], [])\}$，其中三元组表示（当前状态、当前动作序列、当前转换序列）

### 迭代搜索

当队列 $Q$ 非空且已展开节点数小于最大深度 $\text{max\_depth}$ 时，执行以下步骤：

1. **出队操作**：

   - 从队列前端取出一个元素：$(s, A_s, T_s) = Q.\text{popleft}()$
   - 其中 $s$ 是当前状态，$A_s$ 是到达该状态的动作序列，$T_s$ 是相应的状态转换序列
2. **目标检查**：

   - 若状态 $s$ 满足目标条件，即：
     $\forall p \in G^+ : p \in s \text{ 且 } \forall p \in G^- : p \notin s$
   - 其中 $G^+$ 是正目标条件集合，$G^-$ 是负目标条件集合
   - 则记录当前轨迹 $(s_0, A_s, s)$ 为解决方案轨迹
3. **动作随机化**：

   - 获取所有可能的动作 $A = \{a_1, a_2, ..., a_n\}$
   - 随机打乱动作顺序：$A' = \text{shuffle}(A)$
   - 这确保每次搜索时动作的考虑顺序不同，增加探索的多样性
4. **状态扩展**：

   - 对每个随机排序后的动作 $a \in A'$：
     - 检查动作 $a$ 是否可应用于状态 $s$：
       $\text{applicable}(a, s) \iff (\forall p \in P_a^+ : p \in s) \land (\forall p \in P_a^- : p \notin s)$
     - 其中 $P_a^+$ 是动作 $a$ 的正前提条件集合，$P_a^-$ 是负前提条件集合
     - 若动作可应用，则：

       - 计算执行动作后的新状态：
         $s' = T(s, a) = (s \setminus E_a^-) \cup E_a^+$
       - 其中 $E_a^+$ 是动作 $a$ 的添加效果集合，$E_a^-$ 是删除效果集合
       - 创建状态转换记录：
         $t_a = \{\text{from\_state}: s, \text{action}: a, \text{to\_state}: s', ...\}$
       - 检查新状态是否已访问：

         - 若 $s' \notin V$（使用集合操作检查）：
           - 将新状态加入已访问集合：$V = V \cup \{s'\}$
           - 创建新的动作序列：$A_{s'} = A_s \oplus [a]$（$\oplus$ 表示序列连接）
           - 创建新的转换序列：$T_{s'} = T_s \oplus [t_a]$
           - 将新状态及其路径信息入队：$Q.\text{push}((s', A_{s'}, T_{s'}))$
